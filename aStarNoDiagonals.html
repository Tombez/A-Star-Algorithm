<!DOCTYPE HTML>

<html>

<head>
	
	<title>A*</title>
	
	<style>
	body {
		margin: 0px;
	}
	</style>
	
</head>

<body>
	
	<canvas id="canvas" oncontextmenu="return false"></canvas>
	
	<script>
		// User variables:
		var cols = 50;
		var rows = 50;
		var tileSize = 18;
		var sps = 10;
		var start = {x: 15, y: 15};
		var goal = {x: cols - 1, y: rows - 1};
		
		// Global variables:
		var canvas;
		var ctx;
		var loop;
		var tiles;
		var open;
		var current;
		var path;
		var mousemove;
		var noSolution;
		
		// Rainbow tables:
		var directions = [{x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0}, {x: 0, y: 1}]; // Right, up, left, down.
		var mouse = {down: false, x: 0, y: 0};
		var rootTwo = 1.4142135623730951;
		
		// Functions:
		function initCanvas() {
			canvas = document.getElementById("canvas");
			canvas.width = cols * tileSize;
			canvas.height = rows * tileSize;
			ctx = canvas.getContext("2d");
			
			canvas.addEventListener("mousedown", function(event) {
				mouse.down = event.which;
				mouse.x = cols * tileSize * 2;
				mousemove(event);
			});
			window.addEventListener("mouseup", function() {
				mouse.down = false;
			});
			canvas.addEventListener("mousemove", mousemove = function(event) {
				var x = ~~(event.clientX / tileSize);
				var y = ~~(event.clientY / tileSize);
				if (mouse.x != x || mouse.y != y) {
					mouse.x = x;
					mouse.y = y;
					if (mouse.down == 1) {
						tiles[x][y].blocked = true;
					} else if (mouse.down == 3) {
						tiles[x][y].blocked = false;
					}
					if (mouse.down) {
						setTimeout(function() {
							aStar();
							draw();
						}, 1);
					}
				}
			});
		}
		function initTiles() {
			if (!tiles) {
				tiles = [];
				for (var x = 0; x < cols; x++) {
					tiles[x] = [];
					for (var y = 0; y < rows; y++) {
						tiles[x][y] = {};
					}
				}
			} else {
				var newTiles = [];
				for (var x = 0; x < cols; x++) {
					newTiles[x] = [];
					for (var y = 0; y < rows; y++) {
						newTiles[x][y] = {};
						if (tiles[x][y].blocked) {
							newTiles[x][y].blocked = true;
						}
					}
				}
				tiles = newTiles;
			}
			Array.prototype.indexOfPointObj = function(point) {
				for (var n = 0; n < this.length; n++) {
					if (this[n].x == point.x && this[n].y == point.y) {
						return n;
					}
				}
				return -1;
			};
		}
		function cityDist(pointA, pointB) {
			return Math.abs(pointA.x - pointB.x) + Math.abs(pointA.y - pointB.y);
		}
		function diagonalCityDist(pointA, pointB) {
			var difX = (pointA.x < pointB.x) ? (pointB.x - pointA.x) : (pointA.x - pointB.x);
			var difY = (pointA.y < pointB.y) ? (pointB.y - pointA.y) : (pointA.y - pointB.y);
			if (difX < difY) {
				var rootCoefficient = difX;
				var integer = difY - difX;
			} else {
				var rootCoefficient = difY;
				var integer = difX - difY;
			}
			return (integer + (rootCoefficient * rootTwo));
		}
		function euclideanDist(pointA, pointB) {
			if (pointA.x > pointB.x) {
				if (pointA.y > pointB.y) {
					return Math.sqrt((pointA.x - pointB.x) * (pointA.x - pointB.x) + (pointA.y - pointB.y) * (pointA.y - pointB.y));
				} else {
					return Math.sqrt((pointA.x - pointB.x) * (pointA.x - pointB.x) + (pointB.y - pointA.y) * (pointB.y - pointA.y));
				}
			} else {
				if (pointA.y > pointB.y) {
					return Math.sqrt((pointB.x - pointA.x) * (pointB.x - pointA.x) + (pointA.y - pointB.y) * (pointA.y - pointB.y));
				} else {
					return Math.sqrt((pointB.x - pointA.x) * (pointB.x - pointA.x) + (pointB.y - pointA.y) * (pointB.y - pointA.y));
				}
			}
		}
		function distSquared(pointA, pointB) {
			return ((((pointA.x > pointB.x) ? (pointA.x - pointB.x) : (pointB.x - pointA.x)) * ((pointA.x > pointB.x) ? (pointA.x - pointB.x) : (pointB.x - pointA.x))) +
				(((pointA.y > pointB.y) ? (pointA.y - pointB.y) : (pointB.y - pointA.y)) * ((pointA.y > pointB.y) ? (pointA.y - pointB.y) : (pointB.y - pointA.y))));
		}
		function heuristic(point) {
			return cityDist(point, goal);
		}
		function aStar() {
			initTiles();
			tiles[start.x][start.y].g = 0;
			open = [{x: start.x, y: start.y}];
			current = {x: start.x, y: start.y};
			var n;
			var nei; // nei is short for neighbor.
			var tentativeG;
			var least;
			var indices;
			var index;
			var distSqrd;
			while(open.length > 0 && !(current.x == goal.x && current.y == goal.y)) {
				for (n = 0; n < directions.length; n++) {
					nei = {x: current.x + directions[n].x, y: current.y + directions[n].y};
					if ((nei.x == current.x && nei.y == current.y) || nei.x < 0 || nei.x > cols - 1 || nei.y < 0 || nei.y > rows - 1 || tiles[nei.x][nei.y].closed || tiles[nei.x][nei.y].blocked) {
						continue;
					}
					if (tiles[nei.x][nei.y].h == undefined) {
						tiles[nei.x][nei.y].h = heuristic(nei);
					}
					tentativeG = tiles[current.x][current.y].g + cityDist(current, nei);
					if (tiles[nei.x][nei.y].g == undefined || tentativeG < tiles[nei.x][nei.y].g) {
						tiles[nei.x][nei.y].g = tentativeG;
						tiles[nei.x][nei.y].parent = current;
					}
					tiles[nei.x][nei.y].f = tiles[nei.x][nei.y].g + tiles[nei.x][nei.y].h;
					if (open.indexOfPointObj(nei) == - 1) {
						open.push(nei);
					}
				}
				open.splice(open.indexOfPointObj(current), 1);
				tiles[current.x][current.y].closed = true;
				if (open.length == 0) {
					if (current.x != goal.x || current.y != goal.y) {
						noSolution = true;
					} else {
						noSolution = false;
					}
					return;
				}
				least = Number.POSITIVE_INFINITY;
				indices = [];
				for (n = 0; n < open.length; n++) {
					if (tiles[open[n].x][open[n].y].f <= least) {
						least = tiles[open[n].x][open[n].y].f;
						indices.push(n);
					}
				}
				least = Number.POSITIVE_INFINITY;
				index = null;
				for (n = 0; n < indices.length; n++) {
					distSqrd = distSquared(open[indices[n]], goal);
					if (distSqrd < least) {
						least = distSqrd;
						index = n;
					}
				}
				current = {x: open[indices[index]].x, y: open[indices[index]].y};
			}
			if (current.x != goal.x || current.y != goal.y) {
				noSolution = true;
			} else {
				noSolution = false;
			}
		}
		function draw() {
			ctx.beginPath(); // Draw background;
			ctx.fillStyle = "white";
			ctx.rect(0, 0, canvas.width, canvas.height);
			ctx.fill();
			
			ctx.beginPath(); // Draw closed.
			ctx.fillStyle = "pink";
			for (var y = 0; y < rows; y++) {
				for (var x = 0; x < cols; x++) {
					if (tiles[x][y].closed) {
						ctx.rect(x * tileSize, y * tileSize, tileSize, tileSize);
					}
				}
			}
			ctx.fill();
			
			ctx.beginPath(); // Draw open.
			ctx.fillStyle = "skyblue";
			for (var n = 0; n < open.length; n++) {
				ctx.rect(open[n].x * tileSize, open[n].y * tileSize, tileSize, tileSize);
			}
			ctx.fill();
			
			if (current.x != undefined) {
				path = [{x: current.x, y: current.y}];
				var famMem = {x: current.x, y: current.y};
				while (tiles[famMem.x][famMem.y].parent) {
					path.push({x: tiles[famMem.x][famMem.y].parent.x, y: tiles[famMem.x][famMem.y].parent.y});
					famMem = {x: tiles[famMem.x][famMem.y].parent.x, y: tiles[famMem.x][famMem.y].parent.y};
				}
			}
			if (path != undefined) {
				ctx.beginPath(); // Draw path.
				ctx.fillStyle = "lime";
				for (var n = 0; n < path.length; n++) {
					ctx.rect(path[n].x * tileSize, path[n].y * tileSize, tileSize, tileSize);
				}
				ctx.fill();
			}
			
			ctx.beginPath(); // Draw start and goal
			ctx.fillStyle = "purple";
			ctx.rect(start.x * tileSize, start.y * tileSize, tileSize, tileSize);
			ctx.rect(goal.x * tileSize, goal.y * tileSize, tileSize, tileSize);
			ctx.fill();
			
			ctx.beginPath(); // Draw blocked.
			ctx.fillStyle = "black";
			for (var y = 0; y < rows; y++) {
				for (var x = 0; x < cols; x++) {
					if (tiles[x][y].blocked) {
						ctx.rect(x * tileSize, y * tileSize, tileSize, tileSize);
					}
				}
			}
			ctx.fill();
			
			ctx.beginPath(); // Draw grid.
			ctx.strokeStyle = "black";
			for (var x = 0; x <= cols; x++) {
				ctx.moveTo(x * tileSize, 0);
				ctx.lineTo(x * tileSize, canvas.height);
			}
			for (var y = 0; y <= cols; y++) {
				ctx.moveTo(0, y * tileSize);
				ctx.lineTo(canvas.width, y * tileSize);
			}
			ctx.stroke();
			
			if (noSolution) { // Draw no solution.
				ctx.fillStyle = "red";
				ctx.font = "40px Arial";
				ctx.fillText("No Solution :c", 10, canvas.height - 10);
			}
		}
		
		// Main:
		initCanvas();
		aStar();
		draw();
		
	</script>
	
</body>

</html>